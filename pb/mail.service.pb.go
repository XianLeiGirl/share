// Code generated by protoc-gen-service. DO NOT EDIT.
// source: mail.proto

package pb

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	metadata1 "gitlab.gg.com/game_framework/commons-go/metadata"
	server "gitlab.gg.com/game_framework/commons-go/server"
	validator "gitlab.gg.com/game_framework/commons-go/validator"
	wlog "gitlab.gg.com/game_framework/commons-go/wlog"
	grpc "google.golang.org/grpc"
	metadata "google.golang.org/grpc/metadata"
	ioutil "io/ioutil"
	http "net/http"
	url "net/url"
	strings "strings"
)

var _ bytes.Buffer
var _ context.Context
var _ json.Encoder
var _ fmt.Formatter
var _ proto.Buffer
var _ metadata1.Metadata
var _ server.Server
var _ validator.Validator
var _ wlog.Logger
var _ grpc.Server
var _ metadata.MD
var _ = ioutil.ReadAll
var _ = errors.New
var _ http.Server
var _ url.Error
var _ strings.Builder

// 服务全限定名
var MailFQN = "pb.Mail"

type MailService interface {
	Send(context.Context, *MailSystem_SendRequest) (*MailSystem_SendResponse, error)
	Pull(context.Context, *MailSystem_PullRequest) (*MailSystem_PullResponse, error)
	Read(context.Context, *MailSystem_ReadRequest) (*MailSystem_ReadResponse, error)
	Attach(context.Context, *MailSystem_AttachRequest) (*MailSystem_AttachResponse, error)
	Submit(context.Context, *MailSystem_SubmitRequest) (*MailSystem_SubmitResponse, error)
	DeleteGlobalMail(context.Context, *MailSystem_DeleteGlobalMailRequest) (*MailSystem_DeleteGlobalMailResponse, error)
	Remove(context.Context, *MailSystem_RemoveRequest) (*MailSystem_RemoveResponse, error)
	NewGlobalEnv(context.Context, *MailSystem_NewGlobalEnvRequest) (*MailSystem_NewGlobalEnvResponse, error)
	RemoveGlobalEnv(context.Context, *MailSystem_RemoveGlobalEnvRequest) (*MailSystem_RemoveGlobalEnvResponse, error)
}

type MailProxyClient interface {
	Send(ctx context.Context, in *MailSystem_SendRequest, opts ...server.CallOption) (out *MailSystem_SendResponse, err error)
	Pull(ctx context.Context, in *MailSystem_PullRequest, opts ...server.CallOption) (out *MailSystem_PullResponse, err error)
	Read(ctx context.Context, in *MailSystem_ReadRequest, opts ...server.CallOption) (out *MailSystem_ReadResponse, err error)
	Attach(ctx context.Context, in *MailSystem_AttachRequest, opts ...server.CallOption) (out *MailSystem_AttachResponse, err error)
	Submit(ctx context.Context, in *MailSystem_SubmitRequest, opts ...server.CallOption) (out *MailSystem_SubmitResponse, err error)
	DeleteGlobalMail(ctx context.Context, in *MailSystem_DeleteGlobalMailRequest, opts ...server.CallOption) (out *MailSystem_DeleteGlobalMailResponse, err error)
	Remove(ctx context.Context, in *MailSystem_RemoveRequest, opts ...server.CallOption) (out *MailSystem_RemoveResponse, err error)
	NewGlobalEnv(ctx context.Context, in *MailSystem_NewGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_NewGlobalEnvResponse, err error)
	RemoveGlobalEnv(ctx context.Context, in *MailSystem_RemoveGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_RemoveGlobalEnvResponse, err error)
}

type _MailProxyWithGrpcClient struct {
	cli MailClient
}

// 构建一个grpcproxy客户端
func NewMailProxyGrpcClient(conn *grpc.ClientConn) MailProxyClient {
	cli := NewMailClient(conn)

	return &_MailProxyWithGrpcClient{
		cli: cli,
	}
}
func (c *_MailProxyWithGrpcClient) Send(ctx context.Context, in *MailSystem_SendRequest, opts ...server.CallOption) (out *MailSystem_SendResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.Send(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.Send(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) Pull(ctx context.Context, in *MailSystem_PullRequest, opts ...server.CallOption) (out *MailSystem_PullResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.Pull(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.Pull(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) Read(ctx context.Context, in *MailSystem_ReadRequest, opts ...server.CallOption) (out *MailSystem_ReadResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.Read(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.Read(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) Attach(ctx context.Context, in *MailSystem_AttachRequest, opts ...server.CallOption) (out *MailSystem_AttachResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.Attach(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.Attach(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) Submit(ctx context.Context, in *MailSystem_SubmitRequest, opts ...server.CallOption) (out *MailSystem_SubmitResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.Submit(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.Submit(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) DeleteGlobalMail(ctx context.Context, in *MailSystem_DeleteGlobalMailRequest, opts ...server.CallOption) (out *MailSystem_DeleteGlobalMailResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.DeleteGlobalMail(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.DeleteGlobalMail(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) Remove(ctx context.Context, in *MailSystem_RemoveRequest, opts ...server.CallOption) (out *MailSystem_RemoveResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.Remove(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.Remove(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) NewGlobalEnv(ctx context.Context, in *MailSystem_NewGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_NewGlobalEnvResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.NewGlobalEnv(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.NewGlobalEnv(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}
func (c *_MailProxyWithGrpcClient) RemoveGlobalEnv(ctx context.Context, in *MailSystem_RemoveGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_RemoveGlobalEnvResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	// 把请求头数据，转换成grpc的md数据
	if len(reqHeader) > 0 {
		grpcMd := metadata.MD(reqHeader)
		ctx = metadata.NewOutgoingContext(ctx, grpcMd)
	}

	// 这种情况不要求接收响应头
	if callInfo.RespMdAddr == nil {
		return c.cli.RemoveGlobalEnv(ctx, in)
	}

	// 装备好grpc收到的尾巴元数据，最后会转换成respHeader
	var trailMd metadata.MD
	out, err = c.cli.RemoveGlobalEnv(ctx, in, grpc.Trailer(&trailMd))

	// 装备好响应头
	var respHeader metadata1.Metadata
	if len(trailMd) > 0 {
		respHeader = metadata1.Metadata(trailMd)
	} else {
		respHeader = make(metadata1.Metadata)
	}
	*callInfo.RespMdAddr = respHeader

	return
}

type _MailProxyWithHttpClient struct {
	baseurl string
	hc      *http.Client
}

// 构建一个grpcproxy客户端
func NewMailProxyHttpClient(baseurl string, hc *http.Client) (MailProxyClient, error) {
	u, err := url.ParseRequestURI(baseurl)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, errors.New("baseurl scheme nonsupport")
	}
	u.Path = ""
	return &_MailProxyWithHttpClient{
		baseurl: u.String(),
		hc:      hc,
	}, nil
}
func (c *_MailProxyWithHttpClient) Send(ctx context.Context, in *MailSystem_SendRequest, opts ...server.CallOption) (out *MailSystem_SendResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "Send")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_SendResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) Pull(ctx context.Context, in *MailSystem_PullRequest, opts ...server.CallOption) (out *MailSystem_PullResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "Pull")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_PullResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) Read(ctx context.Context, in *MailSystem_ReadRequest, opts ...server.CallOption) (out *MailSystem_ReadResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "Read")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_ReadResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) Attach(ctx context.Context, in *MailSystem_AttachRequest, opts ...server.CallOption) (out *MailSystem_AttachResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "Attach")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_AttachResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) Submit(ctx context.Context, in *MailSystem_SubmitRequest, opts ...server.CallOption) (out *MailSystem_SubmitResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "Submit")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_SubmitResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) DeleteGlobalMail(ctx context.Context, in *MailSystem_DeleteGlobalMailRequest, opts ...server.CallOption) (out *MailSystem_DeleteGlobalMailResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "DeleteGlobalMail")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_DeleteGlobalMailResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) Remove(ctx context.Context, in *MailSystem_RemoveRequest, opts ...server.CallOption) (out *MailSystem_RemoveResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "Remove")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_RemoveResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) NewGlobalEnv(ctx context.Context, in *MailSystem_NewGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_NewGlobalEnvResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "NewGlobalEnv")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_NewGlobalEnvResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}
func (c *_MailProxyWithHttpClient) RemoveGlobalEnv(ctx context.Context, in *MailSystem_RemoveGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_RemoveGlobalEnvResponse, err error) {
	callInfo := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(callInfo)
	}
	// 调置好调用超时时间
	var cancel context.CancelFunc
	ctx, cancel = callInfo.TimeoutContext(ctx)
	if cancel != nil {
		defer cancel()
	}

	// 请求头
	reqHeader := callInfo.ReqMd
	if reqHeader == nil {
		reqHeader = make(metadata1.Metadata)
	}

	// 默认为grpc的例子
	contentType := server.GRPC
	if callInfo.ContentType == server.JSON {
		contentType = server.JSON
	}
	reqHeader.Set("Content-Type", contentType)

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", c.baseurl, MailFQN, "RemoveGlobalEnv")
	body := bytes.NewReader(reqdata)

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	req.Header = http.Header(reqHeader)

	var resp *http.Response
	resp, err = c.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_RemoveGlobalEnvResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	if callInfo.RespMdAddr != nil {
		// 准备好响应头
		var respHeader metadata1.Metadata
		if len(resp.Header) > 0 {
			respHeader = metadata1.Metadata(resp.Header)
		} else {
			respHeader = make(metadata1.Metadata)
		}
		*callInfo.RespMdAddr = respHeader
	}

	return
}

var _ bytes.Buffer
var _ context.Context
var _ json.Encoder
var _ fmt.Formatter
var _ proto.Buffer
var _ metadata1.Metadata
var _ server.Server
var _ validator.Validator
var _ wlog.Logger
var _ grpc.Server
var _ metadata.MD
var _ = ioutil.ReadAll
var _ = errors.New
var _ http.Server
var _ url.Error
var _ strings.Builder

func RegisterMailServiceWithHttp(s *http.Server, srv MailService, opt server.OptionConfig) {
	if s.Handler == nil {
		s.Handler = http.NewServeMux()
	}
	mux, ok := s.Handler.(*http.ServeMux)
	if !ok {
		wlog.Fatal("RegisterMailServiceWithHttp http.Server.Handler is not *http.ServeMux")
	}
	mux.HandleFunc("/pb.Mail/Send", _Mail_Send_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/Pull", _Mail_Pull_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/Read", _Mail_Read_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/Attach", _Mail_Attach_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/Submit", _Mail_Submit_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/DeleteGlobalMail", _Mail_DeleteGlobalMail_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/Remove", _Mail_Remove_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/NewGlobalEnv", _Mail_NewGlobalEnv_WithHttp_Handler(srv, opt))
	mux.HandleFunc("/pb.Mail/RemoveGlobalEnv", _Mail_RemoveGlobalEnv_WithHttp_Handler(srv, opt))
}

func _Mail_Send_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_Send_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_SendRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_Send_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_SendResponse
		respobj, err = srv.Send(ctx, reqobj.(*MailSystem_SendRequest))
		if err != nil {
			wlog.Errorf("_Mail_Send_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_Send_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_Pull_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_Pull_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_PullRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_Pull_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_PullResponse
		respobj, err = srv.Pull(ctx, reqobj.(*MailSystem_PullRequest))
		if err != nil {
			wlog.Errorf("_Mail_Pull_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_Pull_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_Read_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_Read_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_ReadRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_Read_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_ReadResponse
		respobj, err = srv.Read(ctx, reqobj.(*MailSystem_ReadRequest))
		if err != nil {
			wlog.Errorf("_Mail_Read_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_Read_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_Attach_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_Attach_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_AttachRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_Attach_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_AttachResponse
		respobj, err = srv.Attach(ctx, reqobj.(*MailSystem_AttachRequest))
		if err != nil {
			wlog.Errorf("_Mail_Attach_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_Attach_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_Submit_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_Submit_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_SubmitRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_Submit_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_SubmitResponse
		respobj, err = srv.Submit(ctx, reqobj.(*MailSystem_SubmitRequest))
		if err != nil {
			wlog.Errorf("_Mail_Submit_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_Submit_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_DeleteGlobalMail_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_DeleteGlobalMail_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_DeleteGlobalMailRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_DeleteGlobalMail_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_DeleteGlobalMailResponse
		respobj, err = srv.DeleteGlobalMail(ctx, reqobj.(*MailSystem_DeleteGlobalMailRequest))
		if err != nil {
			wlog.Errorf("_Mail_DeleteGlobalMail_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_DeleteGlobalMail_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_Remove_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_Remove_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_RemoveRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_Remove_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_RemoveResponse
		respobj, err = srv.Remove(ctx, reqobj.(*MailSystem_RemoveRequest))
		if err != nil {
			wlog.Errorf("_Mail_Remove_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_Remove_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_NewGlobalEnv_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_NewGlobalEnv_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_NewGlobalEnvRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_NewGlobalEnv_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_NewGlobalEnvResponse
		respobj, err = srv.NewGlobalEnv(ctx, reqobj.(*MailSystem_NewGlobalEnvRequest))
		if err != nil {
			wlog.Errorf("_Mail_NewGlobalEnv_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_NewGlobalEnv_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}
func _Mail_RemoveGlobalEnv_WithHttp_Handler(srv MailService, opt server.OptionConfig) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		// 保证进程不崩溃
		defer func() {
			e := wlog.PrintPanicStack()
			if e != nil {
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(fmt.Sprintf("%v", e)), w)
			}
		}()

		if r.Method != http.MethodPost {
			server.SendHttpResponse(nil, http.StatusMethodNotAllowed, []byte(http.StatusText(http.StatusMethodNotAllowed)), w)
			return
		}

		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			wlog.Errorf("_Mail_RemoveGlobalEnv_WithHttp_Handler err %v", err)
			server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var reqobj proto.Message = &MailSystem_RemoveGlobalEnvRequest{}

		contentType := strings.ToLower(r.Header.Get("Content-Type"))
		if contentType != "" {
			strArray := strings.Split(contentType, ";")
			if len(strArray) > 0 {
				contentType = strings.TrimSpace(strArray[0])
			}
		}

		switch contentType {
		case server.GRPC:
			err = proto.Unmarshal(data, reqobj)
		case server.JSON:
			err = json.Unmarshal(data, reqobj)
		default:
			server.SendHttpResponse(nil, http.StatusUnsupportedMediaType, []byte(http.StatusText(http.StatusUnsupportedMediaType)), w)
			return
		}

		// 如果实现了验证，则验证
		if validator, ok := reqobj.(validator.Validator); ok {
			err = validator.Validate()
			if err != nil {
				wlog.Errorf("_Mail_RemoveGlobalEnv_WithHttp_Handler err %v", err)
				server.SendHttpResponse(nil, http.StatusBadRequest, []byte(err.Error()), w)
				return
			}
		}

		if opt.PrintRequest {
			wlog.Printf("Http-req method: %s, %v", r.URL.Path, reqobj)
		}

		ctx := server.NewMetadataWithHttpRequest(context.Background(), r)

		respHeader := make(metadata1.Metadata)
		ctx = metadata1.NewResponseContext(ctx, respHeader)

		var respobj *MailSystem_RemoveGlobalEnvResponse
		respobj, err = srv.RemoveGlobalEnv(ctx, reqobj.(*MailSystem_RemoveGlobalEnvRequest))
		if err != nil {
			wlog.Errorf("_Mail_RemoveGlobalEnv_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		var respdata []byte
		switch contentType {
		case server.GRPC:
			respdata, err = proto.Marshal(respobj)
		case server.JSON:
			respdata, err = json.Marshal(respobj)
		}

		if err != nil {
			wlog.Errorf("_Mail_RemoveGlobalEnv_WithHttp_Handler err %v", err)
			server.SendHttpResponse(respHeader, http.StatusBadRequest, []byte(err.Error()), w)
			return
		}

		server.SendHttpResponse(respHeader, http.StatusOK, respdata, w)

		if opt.PrintResponse {
			wlog.Printf("Http-resp method: %s, %v", r.URL.Path, respobj)
		}
	}
}

// 构建一个http客户端
func NewMailHttpClient(baseurl string, hc *http.Client) (MailHttpClient, error) {
	u, err := url.ParseRequestURI(baseurl)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, errors.New("baseurl scheme nonsupport")
	}
	u.Path = ""
	return &_MailHttpClient{
		baseurl: u.String(),
		hc:      hc,
	}, nil
}

type MailHttpClient interface {
	Send(in *MailSystem_SendRequest, opts ...server.CallOption) (*MailSystem_SendResponse, metadata1.Metadata, error)
	Pull(in *MailSystem_PullRequest, opts ...server.CallOption) (*MailSystem_PullResponse, metadata1.Metadata, error)
	Read(in *MailSystem_ReadRequest, opts ...server.CallOption) (*MailSystem_ReadResponse, metadata1.Metadata, error)
	Attach(in *MailSystem_AttachRequest, opts ...server.CallOption) (*MailSystem_AttachResponse, metadata1.Metadata, error)
	Submit(in *MailSystem_SubmitRequest, opts ...server.CallOption) (*MailSystem_SubmitResponse, metadata1.Metadata, error)
	DeleteGlobalMail(in *MailSystem_DeleteGlobalMailRequest, opts ...server.CallOption) (*MailSystem_DeleteGlobalMailResponse, metadata1.Metadata, error)
	Remove(in *MailSystem_RemoveRequest, opts ...server.CallOption) (*MailSystem_RemoveResponse, metadata1.Metadata, error)
	NewGlobalEnv(in *MailSystem_NewGlobalEnvRequest, opts ...server.CallOption) (*MailSystem_NewGlobalEnvResponse, metadata1.Metadata, error)
	RemoveGlobalEnv(in *MailSystem_RemoveGlobalEnvRequest, opts ...server.CallOption) (*MailSystem_RemoveGlobalEnvResponse, metadata1.Metadata, error)
}

type _MailHttpClient struct {
	baseurl string
	hc      *http.Client
}

func (cli *_MailHttpClient) Send(in *MailSystem_SendRequest, opts ...server.CallOption) (out *MailSystem_SendResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "Send")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_SendResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) Pull(in *MailSystem_PullRequest, opts ...server.CallOption) (out *MailSystem_PullResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "Pull")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_PullResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) Read(in *MailSystem_ReadRequest, opts ...server.CallOption) (out *MailSystem_ReadResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "Read")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_ReadResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) Attach(in *MailSystem_AttachRequest, opts ...server.CallOption) (out *MailSystem_AttachResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "Attach")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_AttachResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) Submit(in *MailSystem_SubmitRequest, opts ...server.CallOption) (out *MailSystem_SubmitResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "Submit")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_SubmitResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) DeleteGlobalMail(in *MailSystem_DeleteGlobalMailRequest, opts ...server.CallOption) (out *MailSystem_DeleteGlobalMailResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "DeleteGlobalMail")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_DeleteGlobalMailResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) Remove(in *MailSystem_RemoveRequest, opts ...server.CallOption) (out *MailSystem_RemoveResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "Remove")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_RemoveResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) NewGlobalEnv(in *MailSystem_NewGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_NewGlobalEnvResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "NewGlobalEnv")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_NewGlobalEnvResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
func (cli *_MailHttpClient) RemoveGlobalEnv(in *MailSystem_RemoveGlobalEnvRequest, opts ...server.CallOption) (out *MailSystem_RemoveGlobalEnvResponse, header metadata1.Metadata, err error) {
	// 调用选项全部应用一次，生成调用信息
	info := server.NewCallOptions()
	for _, o := range opts {
		o.Apply(info)
	}
	// 默认为grpc的例子
	contentType := server.GRPC
	if info.ContentType == server.JSON {
		contentType = server.JSON
	}

	var reqdata []byte

	switch contentType {
	case server.GRPC:
		reqdata, err = proto.Marshal(in)
	case server.JSON:
		reqdata, err = json.Marshal(in)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}

	url := fmt.Sprintf("%s/%s/%s", cli.baseurl, "pb.Mail", "RemoveGlobalEnv")
	body := bytes.NewReader(reqdata)

	var ctx context.Context
	if info.Timeout <= 0 {
		ctx = context.Background()
	} else {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(context.Background(), info.Timeout)
		defer cancel()
	}

	var req *http.Request
	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, body)
	if err != nil {
		return
	}
	if info.ReqMd != nil {
		req.Header = http.Header(info.ReqMd)
	}

	req.Header.Set("Content-Type", contentType)

	var resp *http.Response
	resp, err = cli.hc.Do(req)
	if err != nil {
		return
	}

	// 不论响应的状态码是什么，包体都需要读
	var respdata []byte
	respdata, err = ioutil.ReadAll(resp.Body)

	if resp.StatusCode != http.StatusOK {
		err = &server.HttpError{
			Status: resp.StatusCode,
			Text:   string(respdata),
		}
		return
	}

	out = &MailSystem_RemoveGlobalEnvResponse{}
	switch contentType {
	case server.GRPC:
		err = proto.Unmarshal(respdata, out)
	case server.JSON:
		err = json.Unmarshal(respdata, out)
	default:
		err = &server.HttpError{
			Status: http.StatusUnsupportedMediaType,
			Text:   http.StatusText(http.StatusUnsupportedMediaType),
		}
	}

	if err != nil {
		return
	}
	if resp.Header == nil {
		header = make(metadata1.Metadata)
	} else {
		header = metadata1.Metadata(resp.Header)
	}

	return
}
